//! # A #[derive] macro for PartialEq implementations that ignore lifetime variance
//!
//! Since Rust 1.65.0, generic associated types are stable. However, one of their downsides
//! is that all lifetimes involved in them are automatically invariant. This has some
//! unfortunate side effects for comparisons, as an innocent expression such as `a == b` can now
//! fail with "`a` does not live long enough". This is because for any lifetime-generic type `T<'a>`,
//! the [`PartialEq`] implementation generated by the built-in `#[derive(PartialEq)]` looks a bit
//! as follows
//! ```no_compile
//! impl<'a> PartialEq<T<'a>> for T<'a> { ... }
//! ```
//! For types with (co/contra)variant lifetime parameters, this is not a problem, as for a
//! comparison such as `T<'a> == T<'static>` rust will unify the lifetimes appropriately. However,
//! if the lifetime parameter is invariant, this is not possible, and the above comparison fails to
//! compile.
//!
//! To see this in action, consider the following code:
//! ```compile_fail
//! trait MyGat {
//!    type Gat<'a>;
//! }
//!
//! #[derive(PartialEq)]
//! struct T<'a, A: MyGat>(A::Gat<'a>);
//!
//! // PartialEq implementation generated looks like
//! // impl<'a, A: PartialEq + MyGat> PartialEq<T<'a, A>> for T<'a, A>
//! // where
//! //    A::Gat<'a>: PartialEq<A::Gat<'a>> { ... }
//! // Note (a) the unneeded PartialEq bound on A and (b) the too-specific bound on A::Gat<'a>
//!
//! #[derive(PartialEq)]
//! struct MyGatImpl;
//!
//! impl MyGat for MyGatImpl {
//!    type Gat<'a> = &'a str;
//! }
//!
//! let s = "hello world!".to_owned();
//! let a = T::<'_, MyGatImpl>(&s);
//! let b = T::<'static, MyGatImpl>("hello world");
//! assert!(a == b)
//! ```
//! However, if instead of deriving [`PartialEq`], we use a manual impl, such as
//! ```
//! trait MyGat {
//!    type Gat<'a>;
//! }
//!
//! struct T<'a, A: MyGat>(A::Gat<'a>);
//!
//! struct MyGatImpl;
//!
//! impl MyGat for MyGatImpl {
//!    type Gat<'a> = &'a str;
//! }
//!
//! impl<'a, 'b, A: MyGat> PartialEq<T<'a, A>> for T<'b, A>
//! where
//!     <A as MyGat>::Gat<'b>: PartialEq<<A as MyGat>::Gat<'a>>
//! {
//!     fn eq(&self, other: &T<'a, A>) -> bool {
//!         self.0 == other.0
//!     }
//! }
//!
//! let s = "hello world!".to_owned();
//! let a = T::<'_, MyGatImpl>(&s);
//! let b = T::<'static, MyGatImpl>("hello world!");
//! assert!(a == b)
//! ```
//! we see that everything compiles and works. The purpose of this crate is to generate [`PartialEq`]
//! implementations of the second kind.
//!
//! ## Limitations
//!
//! The generated implementation assumes that all members of the type on which the derive macro is used
//! have [`PartialEq`] implementations that explicitly ignore variance. This is notoriously not the case.
//! For instance, the [`Option`] type in teh standard library does not, meaning even with the example above,
//! the following slight adjustment will cause compilation to fail again:
//!
//! ```compile_fail
//! # trait MyGat {
//! #    type Gat<'a>;
//! # }
//! #
//! # struct T<'a, A: MyGat>(A::Gat<'a>);
//! #
//! # struct MyGatImpl;
//! #
//! # impl MyGat for MyGatImpl {
//! #    type Gat<'a> = &'a str;
//! # }
//! #
//! # impl<'a, 'b, A: MyGat> PartialEq<T<'a, A>> for T<'b, A>
//! # where
//! #     <A as MyGat>::Gat<'b>: PartialEq<<A as MyGat>::Gat<'a>>
//! # {
//! #     fn eq(&self, other: &T<'a, A>) -> bool {
//! #         self.0 == other.0
//! #     }
//! # }
//! #
//! let s = "hello world!".to_owned();
//! let a = Some(T::<'_, MyGatImpl>(&s));
//! let b = Some(T::<'static, MyGatImpl>("hello world!"));
//! assert!(a == b)
//! ```
//!
//! That is because the [`PartialEq`] implementation for [`Option`] is `impl<T> PartialEq for Option<T>`
//! instead of the more general `impl<T, U: PartialEq<T>> PartialEq<Option<U>> for Option<T>`, for
//! good reason [[1]]. Even this crate cannot work around that, so you will have to write a drop-in
//! comparator and tell the generated [`PartialEq`] implementation to use that via the
//! `#[variant_compare = "..."]` attribute.
//!
//! Furthermore, this crate for now only works with named-field structs that have no generic parameters
//! apart from lifetimes.
//!
//! [1]: https://github.com/rust-lang/rust/issues/20063#issuecomment-105251291

extern crate proc_macro;
use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use proc_macro2::{Ident, Span};

use quote::{quote, quote_spanned};
use syn::{
    parse_macro_input, spanned::Spanned, AttrStyle, Attribute, Data, DeriveInput, Expr, ExprLit,
    Field, Fields, GenericParam, Lifetime, Lit, Meta, Path, TypeParam,
};

/// Derive macro for `PartialEq` implementations that play nicely with invariant lifetimes
///
/// [1]: https://doc.rust-lang.org/reference/procedural-macros.html#derive-mode-macros
#[proc_macro_derive(VariantPartialEq, attributes(variant_compare))]
pub fn variant_partial_eq(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let Data::Struct(data_struct) = input.data else {
        return quote_spanned! {
            Span::call_site() => compile_error!("#[derive(VariantPartialEq)] only works for structs");
        }.into()
    };

    let Fields::Named(named_fields) = data_struct.fields else {
        return quote_spanned!{
            data_struct.fields.span() => compile_error!("#[derive(VariantPartialEq)] only supports structs with names fields");
        }.into()
    };

    let mut lifetimes = Vec::new();
    let mut types = Vec::new();

    for generic in input.generics.params {
        match generic {
            GenericParam::Const(const_param)  => return quote_spanned!{
                const_param.span() => compile_error!("#[derive(VariantPartialEq)] does not support const generics");
            }.into(),
            GenericParam::Type(ty) => {
                if !ty.bounds.is_empty() {
                    return quote_spanned!{
                        ty.bounds.span() => compile_error!("#[derive(VariantPartialEq)] does not support lifetime bounds");
                    }.into()
                }

                types.push(ty);
            }
            GenericParam::Lifetime(lifetime) => {
                if !lifetime.bounds.is_empty() {
                    return quote_spanned!{
                        lifetime.bounds.span() => compile_error!("#[derive(VariantPartialEq)] does not support lifetime bounds");
                    }.into()
                }

                lifetimes.push(lifetime.lifetime)
            }
        }
    }

    let struct_name = input.ident;

    let duped_lifetime_list = duplicate_lifetimes(&lifetimes);
    let (duped_type_param_list, where_clause) = duplicate_type_params(&types);

    // need to string our given type parameters of any defaults
    let mut given_type_params = TokenStream2::new();

    for ty in types {
        let orig_span = ty.span();
        let clone = TypeParam::from(ty.ident);

        given_type_params.extend(quote_spanned!(orig_span => #clone,));
    }

    let comparisons = comparisons(named_fields.named.iter());

    let tokens = quote! {
        impl<#duped_lifetime_list #(#lifetimes,)* #duped_type_param_list #given_type_params> PartialEq<#struct_name<#duped_lifetime_list #duped_type_param_list>> for #struct_name<#(#lifetimes,)* #given_type_params>
        #where_clause
        {
            fn eq(&self, other: &#struct_name<#duped_lifetime_list #duped_type_param_list>) -> bool {
                #(
                    #comparisons
                )&&*
            }
        }
    };

    tokens.into()
}

fn comparisons<'a>(fields: impl Iterator<Item = &'a Field>) -> Vec<proc_macro2::TokenStream> {
    let mut comparison_exprs = Vec::new();

    for field in fields {
        let field_name = field.ident.as_ref().unwrap();

        let mut iter = field
            .attrs
            .iter()
            .filter_map(|attr| comparison_from_attribute(field, attr).map(|ts| (ts, attr)));

        match (iter.next(), iter.next()) {
            // putting the compile_error! into a block that evaluates to true suppresses errors about trying to use && with the unit type
            (Some(_), Some((_, attr))) => comparison_exprs.push(quote_spanned!(attr.meta.span() => {compile_error!("Expected only single #[variant_compare = \"...\"] attribute"); true})),
            (Some((ts, _)), _) => comparison_exprs.push(ts),
            (None, None) => comparison_exprs.push(quote_spanned!(field.span() => self.#field_name == other.#field_name)),
            _ => unreachable!()
        }
    }

    comparison_exprs
}

fn comparison_from_attribute(
    field: &Field,
    attribute: &Attribute,
) -> Option<proc_macro2::TokenStream> {
    if let AttrStyle::Inner(_) = attribute.style {
        return None;
    }

    if let Meta::NameValue(ref name_value) = attribute.meta {
        if name_value.path.leading_colon.is_some() {
            return None;
        }

        if name_value.path.segments.len() != 1 {
            return None;
        }

        if name_value.path.segments[0].ident != "variant_compare" {
            return None;
        }

        if let Expr::Lit(ExprLit {
            lit: Lit::Str(ref str_lit),
            ..
        }) = name_value.value
        {
            let Ok(path): Result<Path, _> = str_lit.parse() else {
                return Some(quote_spanned!(str_lit.span() => {compile_error!("Malformed #[variant_compare = \"...\"] attribute, expected path to comparison function"); true}))
            };

            // At this point, we know that the attributes is #[variant_compare = "path::to::cmp::func"]
            let field_name = field.ident.as_ref().unwrap();

            let mut comparison = quote_spanned!(str_lit.span() => #path);
            comparison
                .extend(quote_spanned!(field.span() => (&self.#field_name, &other.#field_name)));

            return Some(comparison);
        }

        return Some(
            quote_spanned!(attribute.meta.span() => {compile_error!("Malformed #[variant_compare = \"...\"] attribute"); true}),
        );
    }

    None
}

/// Duplicates the given lifetimes
fn duplicate_lifetimes(lifetimes: &[Lifetime]) -> TokenStream2 {
    let mut lifetime_list = TokenStream2::new();

    for lifetime in lifetimes {
        let mut derived_lifetime = format!("'{}_", lifetime.ident);

        'outer: loop {
            for lt in lifetimes {
                if lt.ident == derived_lifetime {
                    derived_lifetime.push('_');
                    continue 'outer;
                }
            }

            break;
        }

        let lifetime = Lifetime::new(&derived_lifetime, Span::call_site());
        lifetime_list.extend(quote!(#lifetime,));
    }

    lifetime_list
}

/// Duplicates the given type parameters
fn duplicate_type_params(type_params: &[TypeParam]) -> (TokenStream2, TokenStream2) {
    let mut param_list = TokenStream2::new();
    let mut where_clause = TokenStream2::new();

    for ty_param in type_params {
        let mut derived_param = format!("{}_", ty_param.ident);

        'outer: loop {
            for ty in type_params {
                if ty.ident == derived_param {
                    derived_param.push('_');
                    continue 'outer;
                }
            }

            break;
        }

        let orig = TypeParam::from(ty_param.ident.clone());
        let param = TypeParam::from(Ident::new(&derived_param, Span::call_site()));

        param_list.extend(quote!(#param,));
        where_clause.extend(quote_spanned!(ty_param.ident.span() => #orig));
        where_clause.extend(quote! {:});
        where_clause.extend(quote! {PartialEq<#param>,});
    }

    if !where_clause.is_empty() {
        where_clause = quote! {
            where #where_clause
        };
    }

    (param_list, where_clause)
}

#[cfg(test)]
mod tests {
    #[test]
    fn ui() {
        let t = trybuild::TestCases::new();
        t.compile_fail("tests/ui/fail/*.rs");
        t.pass("tests/ui/pass/*.rs");
    }
}
